using System.Text.Json;
using System.Text.Json.Nodes;
using DotBot.Localization;
using DotBot.Mcp;

namespace DotBot.Configuration;

public sealed class AppConfig
{
    public string ApiKey { get; set; } = string.Empty;

    public string Model { get; set; } = "gpt-4o-mini";

    public string EndPoint { get; set; } = "https://api.openai.com/v1";

    public string SystemInstructions { get; set; } = "你是 DotBot 一个安全可靠的智能体。";

    /// <summary>
    /// Language setting for CLI interface. QQ and WeCom bots always use Chinese.
    /// </summary>
    public Language Language { get; set; } = Language.Chinese;

    public int MaxToolCallRounds { get; set; } = 100;

    public int SubagentMaxToolCallRounds { get; set; } = 50;

    /// <summary>
    /// Maximum number of subagents that can run concurrently.
    /// Controls parallel API call pressure. Excess subagents will queue and wait.
    /// </summary>
    public int SubagentMaxConcurrency { get; set; } = 3;

    /// <summary>
    /// Enable compact sessions to reduce context cost but may cause context cache miss.
    /// </summary>
    public bool CompactSessions { get; set; } = true;

    /// <summary>
    /// Maximum cumulative input tokens before triggering context compaction.
    /// When the total input tokens across all turns in a session exceed this value,
    /// the conversation history will be summarized to reduce context size.
    /// Set to 0 to disable automatic compaction (default: 160K => 80% * 200K context length for popular models).
    /// </summary>
    public int MaxContextTokens { get; set; } = 160000;

    /// <summary>
    /// Number of messages in a session before triggering background memory consolidation.
    /// When exceeded, old messages are consolidated into MEMORY.md (long-term facts) and
    /// HISTORY.md (grep-searchable event log) via an LLM call.
    /// Set to 0 to disable message-count-based consolidation (default: 50).
    /// </summary>
    public int MemoryWindow { get; set; } = 50;

    /// <summary>
    /// Enable debug mode to display full tool call arguments without truncation.
    /// Can be toggled at runtime by administrators using /debug command in QQ/WeCom bots.
    /// </summary>
    public bool DebugMode { get; set; }

    /// <summary>
    /// Filter which tools are globally available in all modes.
    /// Empty list means all tools are enabled.
    /// </summary>
    public List<string> EnabledTools { get; set; } = [];

    public ToolsConfig Tools { get; set; } = new();

    public QQBotConfig QQBot { get; set; } = new();

    public SecurityConfig Security { get; set; } = new();

    public HeartbeatConfig Heartbeat { get; set; } = new();

    public WeComConfig WeCom { get; set; } = new();

    public WeComBotConfig WeComBot { get; set; } = new();

    public CronConfig Cron { get; set; } = new();

    public ApiConfig Api { get; set; } = new();

    public DashBoardConfig DashBoard { get; set; } = new();

    public GatewayConfig Gateway { get; set; } = new();

    public List<McpServerConfig> McpServers { get; set; } = [];

    public static AppConfig Load(string path)
    {
        if (!File.Exists(path))
        {
            return new AppConfig();
        }

        var json = File.ReadAllText(path);
        return JsonSerializer.Deserialize<AppConfig>(json, SerializerOptions) ?? new AppConfig();
    }

    public static AppConfig LoadWithGlobalFallback(string workspacePath)
    {
        var globalConfigPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
            ".bot",
            "appsettings.json");

        // Load as JsonNode for proper merging
        JsonNode? globalNode = File.Exists(globalConfigPath)
            ? JsonNode.Parse(File.ReadAllText(globalConfigPath))
            : new JsonObject();

        JsonNode? workspaceNode = File.Exists(workspacePath)
            ? JsonNode.Parse(File.ReadAllText(workspacePath))
            : new JsonObject();

        // Merge workspace config into global config (workspace values take precedence)
        var mergedNode = MergeNodes(globalNode ?? new JsonObject(), workspaceNode ?? new JsonObject());

        // Deserialize merged result
        return mergedNode.Deserialize<AppConfig>(SerializerOptions) ?? new AppConfig();
    }

    private static JsonNode MergeNodes(JsonNode baseNode, JsonNode overrideNode)
    {
        if (overrideNode is JsonObject overrideObj && baseNode is JsonObject baseObj)
        {
            var result = JsonSerializer.Deserialize<JsonObject>(baseObj.ToJsonString()) ?? [];

            foreach (var property in overrideObj)
            {
                if (result.TryGetPropertyValue(property.Key, out var existingValue))
                {
                    result[property.Key] = MergeNodes(existingValue ?? new JsonObject(), property.Value ?? new JsonObject());
                }
                else
                {
                    result[property.Key] = property.Value?.DeepClone();
                }
            }

            return result;
        }

        // For arrays and values, override node takes precedence if it exists
        return overrideNode.DeepClone();
    }

    private static readonly JsonSerializerOptions SerializerOptions = new()
    {
        PropertyNameCaseInsensitive = true
    };

    public sealed class ToolsConfig
    {
        public FileToolsConfig File { get; set; } = new();
        
        public ShellToolsConfig Shell { get; set; } = new();
        
        public WebToolsConfig Web { get; set; } = new();
    }

    public sealed class FileToolsConfig
    {
        /// <summary>
        /// If true, operations outside workspace require user approval.
        /// If false, operations outside workspace are completely blocked.
        /// </summary>
        public bool RequireApprovalOutsideWorkspace { get; set; } = true;

        /// <summary>
        /// Maximum file size in bytes (default: 10 MB).
        /// </summary>
        public int MaxFileSize { get; set; } = 10 * 1024 * 1024;
    }

    public sealed class ShellToolsConfig
    {
        /// <summary>
        /// If true, commands accessing paths outside workspace require user approval.
        /// If false, commands accessing paths outside workspace are completely blocked.
        /// </summary>
        public bool RequireApprovalOutsideWorkspace { get; set; } = true;

        /// <summary>
        /// Command execution timeout in seconds.
        /// </summary>
        public int Timeout { get; set; } = 300;

        /// <summary>
        /// Maximum output length in characters.
        /// </summary>
        public int MaxOutputLength { get; set; } = 10000;
    }

    public sealed class WebToolsConfig
    {
        /// <summary>
        /// Maximum characters to extract from fetched content (default: 50000).
        /// </summary>
        public int MaxChars { get; set; } = 50000;

        /// <summary>
        /// Request timeout in seconds (default: 30).
        /// </summary>
        public int Timeout { get; set; } = 30;

        /// <summary>
        /// Default maximum number of search results to return (default: 5, range: 1-10).
        /// </summary>
        public int SearchMaxResults { get; set; } = 5;

        /// <summary>
        /// Search provider: "Bing" (default, globally accessible), "Exa" (AI-optimized, free via MCP), or "DuckDuckGo" (may be blocked by CAPTCHA).
        /// </summary>
        public string SearchProvider { get; set; } = "Bing";
    }

    public sealed class QQBotConfig
    {
        public bool Enabled { get; set; }

        public string Host { get; set; } = "0.0.0.0";

        public int Port { get; set; } = 6700;

        public string AccessToken { get; set; } = string.Empty;

        public List<long> AdminUsers { get; set; } = [];

        public List<long> WhitelistedUsers { get; set; } = [];

        public List<long> WhitelistedGroups { get; set; } = [];

        public int ApprovalTimeoutSeconds { get; set; } = 60;
    }

    public sealed class SecurityConfig
    {
        public List<string> BlacklistedPaths { get; set; } = [];
    }

    public sealed class HeartbeatConfig
    {
        public bool Enabled { get; set; }
        
        public int IntervalSeconds { get; set; } = 1800;
        
        public bool NotifyAdmin { get; set; } = true;
    }

    public sealed class WeComConfig
    {
        public bool Enabled { get; set; }

        /// <summary>
        /// Full webhook URL including key, e.g. https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=YOUR_KEY
        /// </summary>
        public string WebhookUrl { get; set; } = string.Empty;
    }

    public sealed class WeComBotConfig
    {
        /// <summary>
        /// Enable WeCom Bot service (receive messages and events)
        /// </summary>
        public bool Enabled { get; set; }

        /// <summary>
        /// Host to bind the HTTP server (default: 0.0.0.0)
        /// </summary>
        public string Host { get; set; } = "0.0.0.0";

        /// <summary>
        /// Port to bind the HTTP server (default: 9000)
        /// </summary>
        public int Port { get; set; } = 9000;

        /// <summary>
        /// List of admin user IDs (WeCom userId strings)
        /// </summary>
        public List<string> AdminUsers { get; set; } = [];

        /// <summary>
        /// List of whitelisted user IDs (WeCom userId strings)
        /// </summary>
        public List<string> WhitelistedUsers { get; set; } = [];

        /// <summary>
        /// List of whitelisted chat IDs
        /// </summary>
        public List<string> WhitelistedChats { get; set; } = [];

        /// <summary>
        /// Approval request timeout in seconds (default: 60)
        /// </summary>
        public int ApprovalTimeoutSeconds { get; set; } = 60;

        /// <summary>
        /// List of bot configurations (each bot corresponds to a path)
        /// </summary>
        public List<WeComRobotConfig> Robots { get; set; } = [];

        /// <summary>
        /// Default robot configuration (for unmatched paths)
        /// </summary>
        public WeComRobotConfig? DefaultRobot { get; set; }
    }

    public sealed class WeComRobotConfig
    {
        /// <summary>
        /// Bot path (e.g., /dotbot)
        /// </summary>
        public string Path { get; set; } = string.Empty;

        /// <summary>
        /// Token from WeCom bot configuration
        /// </summary>
        public string Token { get; set; } = string.Empty;

        /// <summary>
        /// EncodingAESKey (43 chars without trailing '=')
        /// </summary>
        public string AesKey { get; set; } = string.Empty;
    }

    public sealed class CronConfig
    {
        public bool Enabled { get; set; } = true;
        
        public string StorePath { get; set; } = "cron/jobs.json";
    }

    public sealed class ApiConfig
    {
        public bool Enabled { get; set; }

        public string Host { get; set; } = "0.0.0.0";

        public int Port { get; set; } = 8080;

        public string ApiKey { get; set; } = string.Empty;

        public bool AutoApprove { get; set; } = true;

        /// <summary>
        /// Approval mode for sensitive operations in API mode.
        /// "auto" = auto-approve all operations (default, same as AutoApprove=true).
        /// "reject" = auto-reject all operations (same as AutoApprove=false).
        /// "interactive" = pause and wait for approval via /v1/approvals endpoint (Human-in-the-Loop).
        /// When set, takes precedence over AutoApprove.
        /// </summary>
        public string ApprovalMode { get; set; } = string.Empty;

        /// <summary>
        /// Timeout in seconds for interactive approval requests (default: 120).
        /// If no approval decision is received within this time, the operation is rejected.
        /// Only applies when ApprovalMode is "interactive".
        /// </summary>
        public int ApprovalTimeoutSeconds { get; set; } = 120;

    }

    public sealed class DashBoardConfig
    {
        public bool Enabled { get; set; }

        public int Port { get; set; } = 5880;

        public string Host { get; set; } = "127.0.0.1";
    }

    public sealed class GatewayConfig
    {
        /// <summary>
        /// When true, all enabled channel modules (QQ, WeCom, API) run concurrently
        /// in a single process, sharing infrastructure (CronService, HeartbeatService, DashBoard).
        /// </summary>
        public bool Enabled { get; set; }
    }
}
