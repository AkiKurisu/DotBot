using DotBot.Abstractions;
using DotBot.Agents;
using DotBot.Api;
using DotBot.Configuration;
using DotBot.Cron;
using DotBot.DashBoard;
using DotBot.Heartbeat;
using DotBot.Hosting;
using DotBot.Memory;
using DotBot.Security;
using DotBot.Skills;
using Microsoft.Extensions.DependencyInjection;
using Spectre.Console;

namespace DotBot.Gateway;

/// <summary>
/// Hosts multiple channel services concurrently (QQ, WeCom, API) sharing
/// a single CronService, HeartbeatService, and DashBoardServer instance.
/// Enabled when <see cref="AppConfig.GatewayConfig.Enabled"/> is true.
/// </summary>
public sealed class GatewayHost : IDotBotHost
{
    private readonly IServiceProvider _sp;
    private readonly AppConfig _config;
    private readonly DotBotPaths _paths;
    private readonly SessionStore _sessionStore;
    private readonly SkillsLoader _skillsLoader;
    private readonly CronService _cronService;
    private readonly IReadOnlyList<IChannelService> _channels;
    private readonly MessageRouter _router;

    public GatewayHost(
        IServiceProvider sp,
        AppConfig config,
        DotBotPaths paths,
        SessionStore sessionStore,
        SkillsLoader skillsLoader,
        CronService cronService,
        IEnumerable<IChannelService> channels,
        MessageRouter router)
    {
        _sp = sp;
        _config = config;
        _paths = paths;
        _sessionStore = sessionStore;
        _skillsLoader = skillsLoader;
        _cronService = cronService;
        _channels = channels.ToList();
        _router = router;

        foreach (var ch in _channels)
            _router.RegisterChannel(ch);
    }

    public async Task RunAsync(CancellationToken cancellationToken = default)
    {
        var traceStore = _sp.GetService<TraceStore>();
        var tokenUsageStore = _sp.GetService<TokenUsageStore>();

        // Dashboard startup is owned by GatewayHost.
        // When an API channel is present the dashboard is mounted on its web app to avoid port conflicts.
        // When no API channel exists a standalone DashBoardServer is started instead.
        DashBoardServer? dashBoardServer = null;
        if (_config.DashBoard.Enabled && traceStore != null)
        {
            var apiChannel = _channels.OfType<ApiChannelService>().FirstOrDefault();
            if (apiChannel != null)
            {
                var capturedTraceStore = traceStore;
                var capturedTokenUsageStore = tokenUsageStore;
                apiChannel.OnConfigureApp = app =>
                {
                    app.MapDashBoard(capturedTraceStore, _config, capturedTokenUsageStore);
                };
                var dashboardUrl = $"http://{_config.Api.Host}:{_config.Api.Port}";
                AnsiConsole.MarkupLine(
                    $"[green]DashBoard started at[/] [link={dashboardUrl}/dashboard]{dashboardUrl}/dashboard[/]");
            }
            else
            {
                dashBoardServer = new DashBoardServer();
                dashBoardServer.Start(traceStore, _config, tokenUsageStore);
            }
        }

        // Build a shared agent runner for heartbeat/cron
        var sharedAgentRunner = BuildSharedAgentRunner();

        // Heartbeat service (shared, notifies all admin channels)
        using var heartbeatService = new HeartbeatService(
            _paths.BotPath,
            onHeartbeat: sharedAgentRunner,
            intervalSeconds: _config.Heartbeat.IntervalSeconds,
            enabled: _config.Heartbeat.Enabled);

        if (_config.Heartbeat.NotifyAdmin)
        {
            heartbeatService.OnResult = async result =>
                await _router.BroadcastToAdminsAsync($"[Heartbeat] {result}");
        }

        // Cron service (shared, routes delivery via MessageRouter)
        _cronService.OnJob = async job =>
        {
            var sessionKey = $"cron:{job.Id}";
            var result = await sharedAgentRunner(job.Payload.Message, sessionKey);
            if (job.Payload.Deliver && result != null)
            {
                var channel = job.Payload.Channel ?? "wecom";
                var target = job.Payload.To ?? job.Payload.CreatorId ?? "";
                try
                {
                    await _router.DeliverAsync(channel, target, result);
                }
                catch (Exception ex)
                {
                    await Console.Error.WriteLineAsync($"[Cron] Delivery failed: {ex.Message}");
                }
            }
        };

        if (_config.Heartbeat.Enabled)
        {
            heartbeatService.Start();
            AnsiConsole.MarkupLine(
                $"[green][[Gateway]][/] Heartbeat started (interval: {_config.Heartbeat.IntervalSeconds}s)");
        }

        if (_config.Cron.Enabled)
        {
            _cronService.Start();
            AnsiConsole.MarkupLine(
                $"[green][[Gateway]][/] Cron service started ({_cronService.ListJobs().Count} jobs)");
        }

        PrintStartupSummary();

        // Start all channels concurrently
        using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

        var channelTasks = _channels
            .Select(ch => RunChannelAsync(ch, cts.Token))
            .ToList();

        // Wait for Ctrl+C or external cancellation
        await WaitForShutdownSignalAsync(cancellationToken);

        AnsiConsole.MarkupLine("[yellow][[Gateway]] Shutting down...[/]");

        // Signal all channels to stop
        await cts.CancelAsync();

        // Wait for all channel tasks to complete (they stop gracefully on cancellation)
        await Task.WhenAll(channelTasks);

        heartbeatService.Stop();
        _cronService.Stop();

        if (dashBoardServer != null)
            await dashBoardServer.DisposeAsync();

        AnsiConsole.MarkupLine("[grey][[Gateway]] All channels stopped.[/]");
    }

    private Func<string, string, Task<string?>> BuildSharedAgentRunner()
    {
        var memoryStore = _sp.GetRequiredService<MemoryStore>();
        var pathBlacklist = _sp.GetRequiredService<PathBlacklist>();
        var mcpClientManager = _sp.GetRequiredService<DotBot.Mcp.McpClientManager>();
        var cronTools = _sp.GetService<CronTools>();
        var traceCollector = _sp.GetService<TraceCollector>();

        // Use a console approval service for background (heartbeat/cron) tasks
        var approvalService = new DotBot.Security.ConsoleApprovalService();

        var agentFactory = new AgentFactory(
            _paths.BotPath, _paths.WorkspacePath, _config,
            memoryStore, _skillsLoader, approvalService, pathBlacklist,
            toolProviders: null,
            toolProviderContext: new ToolProviderContext
            {
                Config = _config,
                ChatClient = new OpenAI.OpenAIClient(
                    new System.ClientModel.ApiKeyCredential(_config.ApiKey),
                    new OpenAI.OpenAIClientOptions { Endpoint = new Uri(_config.EndPoint) })
                    .GetChatClient(_config.Model),
                WorkspacePath = _paths.WorkspacePath,
                BotPath = _paths.BotPath,
                MemoryStore = memoryStore,
                SkillsLoader = _skillsLoader,
                ApprovalService = approvalService,
                PathBlacklist = pathBlacklist,
                CronTools = cronTools,
                McpClientManager = mcpClientManager.Tools.Count > 0 ? mcpClientManager : null,
                TraceCollector = traceCollector
            },
            traceCollector: traceCollector);

        var agent = agentFactory.CreateDefaultAgent();
        var runner = new AgentRunner(agent, _sessionStore, agentFactory, traceCollector);
        return runner.RunAsync;
    }

    private static async Task RunChannelAsync(IChannelService channel, CancellationToken ct)
    {
        try
        {
            await channel.StartAsync(ct);
        }
        catch (OperationCanceledException)
        {
            // Normal shutdown
        }
        catch (Exception ex)
        {
            AnsiConsole.MarkupLine(
                $"[grey][[Gateway]][/] [red]Channel '{Markup.Escape(channel.Name)}' failed: {Markup.Escape(ex.Message)}[/]");
        }
    }

    private void PrintStartupSummary()
    {
        AnsiConsole.MarkupLine("[green][[Gateway]][/] Starting with channels:");
        foreach (var ch in _channels)
        {
            AnsiConsole.MarkupLine($"[grey]  - {ch.Name}[/]");
        }
        AnsiConsole.MarkupLine("[grey]Press Ctrl+C to stop...[/]");
    }

    private static async Task WaitForShutdownSignalAsync(CancellationToken cancellationToken)
    {
        var tcs = new TaskCompletionSource();
        Console.CancelKeyPress += (_, e) =>
        {
            e.Cancel = true;
            tcs.TrySetResult();
        };
        await using var reg = cancellationToken.Register(() => tcs.TrySetResult());
        await tcs.Task;
    }

    public ValueTask DisposeAsync()
    {
        return ValueTask.CompletedTask;
    }
}
