using System.ComponentModel;
using System.Text;
using System.Text.RegularExpressions;
using DotBot.Security;
using DotBot.Attributes;

namespace DotBot.Tools;

/// <summary>
/// File system tools: read, write, edit, search files with safety guards.
/// </summary>
public sealed class FileTools(
    string workspaceRoot,
    bool requireApprovalOutsideWorkspace = true,
    int maxFileSize = 10 * 1024 * 1024,
    IApprovalService? approvalService = null,
    PathBlacklist? blacklist = null,
    IReadOnlyList<string>? trustedReadPaths = null)
{
    private const int DefaultReadLimit = 2000;
    
    private const int MaxLineLength = 2000;
    
    private const int MaxGrepMatches = 100;
    
    private const int MaxFindResults = 200;
    
    private const int MaxGrepFileSize = 5 * 1024 * 1024;

    private static readonly HashSet<string> BinaryExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".zip", ".tar", ".gz", ".7z", ".rar", ".bz2", ".xz",
        ".exe", ".dll", ".so", ".dylib", ".pdb",
        ".class", ".jar", ".war",
        ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".ico", ".webp", ".tiff",
        ".mp3", ".mp4", ".avi", ".mkv", ".wav", ".flac", ".ogg", ".webm",
        ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
        ".odt", ".ods", ".odp",
        ".bin", ".dat", ".obj", ".o", ".a", ".lib",
        ".wasm", ".pyc", ".pyo",
        ".ttf", ".otf", ".woff", ".woff2", ".eot",
        ".db", ".sqlite", ".mdb", ".ldb"
    };

    private static readonly HashSet<string> SkipDirectories = new(StringComparer.OrdinalIgnoreCase)
    {
        ".git", "node_modules"
    };

    private readonly string _workspaceRoot = Path.GetFullPath(workspaceRoot);
    
    private readonly IReadOnlyList<string> _trustedReadPaths = trustedReadPaths ?? [];

    [Description("Read the contents of a file or list the contents of a directory. If the path is a directory, lists its entries. Supports offset and limit for paginated reading of large files.")]
    [ToolIcon(Icon = "📄")]
    public async Task<string> ReadFile(
        [Description("The workspace-relative or absolute path to read.")] string path,
        [Description("The line number to start reading from (1-indexed). Enables line-numbered output when set.")] int offset = 0,
        [Description("The maximum number of lines to read (defaults to 2000 when offset is used).")] int limit = 0)
    {
        try
        {
            var fullPath = ResolvePath(path);
            var validateResult = await ValidatePathAsync(fullPath, "read", path);
            if (validateResult != null)
                return validateResult;

            if (Directory.Exists(fullPath))
                return FormatDirectoryListing(fullPath, path);

            if (!File.Exists(fullPath))
                return $"Error: File not found: {path}";

            var fileInfo = new FileInfo(fullPath);
            if (fileInfo.Length > maxFileSize)
                return $"Error: File too large ({fileInfo.Length} bytes). Max size: {maxFileSize} bytes.";

            if (offset > 0)
            {
                var lines = await File.ReadAllLinesAsync(fullPath, Encoding.UTF8);
                var startIndex = offset - 1;
                if (startIndex >= lines.Length)
                    return $"Error: Offset {offset} is out of range for this file ({lines.Length} lines).";

                var readLimit = limit > 0 ? limit : DefaultReadLimit;
                var endIndex = Math.Min(lines.Length, startIndex + readLimit);
                var sb = new StringBuilder();
                for (var i = startIndex; i < endIndex; i++)
                {
                    var line = lines[i].Length > MaxLineLength
                        ? lines[i][..MaxLineLength] + "..."
                        : lines[i];
                    sb.AppendLine($"{i + 1}: {line}");
                }

                if (endIndex < lines.Length)
                    sb.AppendLine($"\n(Showing lines {offset}-{endIndex} of {lines.Length}. Use offset={endIndex + 1} to read more.)");
                else
                    sb.AppendLine($"\n(End of file - total {lines.Length} lines)");

                return sb.ToString();
            }

            return await File.ReadAllTextAsync(fullPath, Encoding.UTF8);
        }
        catch (UnauthorizedAccessException)
        {
            return $"Error: Permission denied: {path}";
        }
        catch (Exception ex)
        {
            return $"Error reading file: {ex.Message}";
        }
    }

    [Description("Write content to a file at the given path. Creates parent directories if needed.")]
    [ToolIcon(Icon = "✏️")]
    public async Task<string> WriteFile(
        [Description("The workspace-relative or absolute file path to write to.")] string path,
        [Description("The content to write.")] string content)
    {
        try
        {
            var fullPath = ResolvePath(path);
            var validateResult = await ValidatePathAsync(fullPath, "write", path);
            if (validateResult != null)
                return validateResult;

            var directory = Path.GetDirectoryName(fullPath);
            if (!string.IsNullOrEmpty(directory))
                Directory.CreateDirectory(directory);

            await File.WriteAllTextAsync(fullPath, content, Encoding.UTF8);
            return $"Successfully wrote {content.Length} bytes to {path}";
        }
        catch (UnauthorizedAccessException)
        {
            return $"Error: Permission denied: {path}";
        }
        catch (Exception ex)
        {
            return $"Error writing file: {ex.Message}";
        }
    }

    [Description("Edit a file. Two modes: (1) Search/Replace - provide oldText and newText, with automatic fuzzy matching fallback for whitespace/indentation differences. (2) Line range - provide startLine and endLine to replace specific lines with newText (pairs with ReadFile offset/limit).")]
    [ToolIcon(Icon = "🔄")]
    public async Task<string> EditFile(
        [Description("The workspace-relative or absolute file path to edit.")] string path,
        [Description("The text to find and replace. Required for search/replace mode, ignored in line range mode.")] string oldText = "",
        [Description("The replacement text.")] string newText = "",
        [Description("Start line number (1-indexed) for line range replacement. When set, switches to line range mode.")] int startLine = 0,
        [Description("End line number (1-indexed, inclusive) for line range replacement. Defaults to startLine if not set.")] int endLine = 0)
    {
        try
        {
            var fullPath = ResolvePath(path);
            var validateResult = await ValidatePathAsync(fullPath, "edit", path);
            if (validateResult != null)
                return validateResult;

            if (!File.Exists(fullPath))
                return $"Error: File not found: {path}";

            var content = await File.ReadAllTextAsync(fullPath, Encoding.UTF8);
            newText = UnescapeUnicodeSequences(newText);

            if (startLine > 0)
                return await ApplyLineRangeEdit(fullPath, path, content, newText, startLine, endLine);

            if (string.IsNullOrEmpty(oldText))
                return "Error: oldText is required for search/replace mode. Use startLine/endLine for line range mode.";

            oldText = UnescapeUnicodeSequences(oldText);
            return await ApplySearchReplaceEdit(fullPath, path, content, oldText, newText);
        }
        catch (UnauthorizedAccessException)
        {
            return $"Error: Permission denied: {path}";
        }
        catch (Exception ex)
        {
            return $"Error editing file: {ex.Message}";
        }
    }

    [Description("Search file contents using a regular expression pattern. Returns matching lines with file paths and line numbers. Skips binary files and .git/node_modules directories.")]
    [ToolIcon(Icon = "🔍")]
    public async Task<string> GrepFiles(
        [Description("The regular expression pattern to search for.")] string pattern,
        [Description("The directory to search in. Defaults to workspace root.")] string path = "",
        [Description("File name pattern to include (e.g. \"*.cs\", \"*.json\"). Searches all text files if not specified.")] string include = "")
    {
        try
        {
            var searchPath = string.IsNullOrEmpty(path) ? _workspaceRoot : ResolvePath(path);
            var validateResult = await ValidatePathAsync(searchPath, "read", string.IsNullOrEmpty(path) ? "." : path);
            if (validateResult != null)
                return validateResult;

            if (!Directory.Exists(searchPath))
                return $"Error: Directory not found: {path}";

            Regex regex;
            try
            {
                regex = new Regex(pattern, RegexOptions.Compiled, TimeSpan.FromSeconds(5));
            }
            catch (ArgumentException ex)
            {
                return $"Error: Invalid regex pattern: {ex.Message}";
            }

            var includePattern = string.IsNullOrEmpty(include) ? null : include;
            var files = EnumerateSearchableFiles(searchPath, includePattern);
            var matches = new List<(string FilePath, int LineNum, string LineText)>();
            var totalMatches = 0;

            foreach (var filePath in files)
            {
                if (totalMatches >= MaxGrepMatches)
                    break;

                try
                {
                    var fileInfo = new FileInfo(filePath);
                    if (fileInfo.Length > MaxGrepFileSize || fileInfo.Length == 0)
                        continue;

                    if (IsBinaryFile(filePath))
                        continue;

                    var lines = await File.ReadAllLinesAsync(filePath, Encoding.UTF8);
                    for (var i = 0; i < lines.Length; i++)
                    {
                        if (regex.IsMatch(lines[i]))
                        {
                            totalMatches++;
                            matches.Add((filePath, i + 1, lines[i]));
                            if (totalMatches >= MaxGrepMatches)
                                break;
                        }
                    }
                }
                catch
                {
                    // ignored
                }
            }

            if (matches.Count == 0)
                return "No matches found.";

            var sb = new StringBuilder();
            sb.AppendLine($"Found {matches.Count} matches{(totalMatches >= MaxGrepMatches ? $" (showing first {MaxGrepMatches}, there may be more)" : "")}:");

            var currentFile = "";
            foreach (var match in matches)
            {
                var relativePath = Path.GetRelativePath(searchPath, match.FilePath);
                if (currentFile != relativePath)
                {
                    if (currentFile != "")
                        sb.AppendLine();
                    currentFile = relativePath;
                    sb.AppendLine($"{relativePath}:");
                }
                var lineText = match.LineText.Length > MaxLineLength
                    ? match.LineText[..MaxLineLength] + "..."
                    : match.LineText;
                sb.AppendLine($"  Line {match.LineNum}: {lineText}");
            }

            return sb.ToString();
        }
        catch (Exception ex)
        {
            return $"Error searching files: {ex.Message}";
        }
    }

    [Description("Find files by name pattern. Searches recursively, skipping .git and node_modules directories. Use semicolons to separate multiple patterns (e.g. \"*.cs;*.json\").")]
    [ToolIcon(Icon = "📂")]
    public async Task<string> FindFiles(
        [Description("The file name pattern to match (e.g. \"*.cs\", \"*.json\"). Use semicolons for multiple patterns.")] string pattern,
        [Description("The directory to search in. Defaults to workspace root.")] string path = "")
    {
        try
        {
            var searchPath = string.IsNullOrEmpty(path) ? _workspaceRoot : ResolvePath(path);
            var validateResult = await ValidatePathAsync(searchPath, "read", string.IsNullOrEmpty(path) ? "." : path);
            if (validateResult != null)
                return validateResult;

            if (!Directory.Exists(searchPath))
                return $"Error: Directory not found: {path}";

            var patterns = pattern.Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
            var files = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            foreach (var p in patterns)
            {
                foreach (var f in EnumerateFilesRecursive(searchPath, p))
                    files.Add(f);
            }

            var sorted = files
                .Select(f =>
                {
                    try { return (Path: f, ModTime: File.GetLastWriteTimeUtc(f)); }
                    catch { return (Path: f, ModTime: DateTime.MinValue); }
                })
                .OrderByDescending(f => f.ModTime)
                .Take(MaxFindResults)
                .ToList();

            if (sorted.Count == 0)
                return "No files found.";

            var truncated = files.Count > MaxFindResults;
            var sb = new StringBuilder();
            sb.AppendLine($"Found {files.Count} files{(truncated ? $" (showing first {MaxFindResults})" : "")}:");
            foreach (var f in sorted)
            {
                sb.AppendLine(Path.GetRelativePath(searchPath, f.Path));
            }

            if (truncated)
                sb.AppendLine($"\n(Results truncated. Consider using a more specific path or pattern.)");

            return sb.ToString();
        }
        catch (Exception ex)
        {
            return $"Error finding files: {ex.Message}";
        }
    }

    #region Private Helpers

    private static string FormatDirectoryListing(string fullPath, string originalPath)
    {
        var items = Directory.GetFileSystemEntries(fullPath)
            .OrderBy(x => x)
            .Select(x =>
            {
                var name = Path.GetFileName(x);
                var prefix = Directory.Exists(x) ? "\uD83D\uDCC1 " : "\uD83D\uDCC4 ";
                return $"{prefix}{name}";
            });

        var result = string.Join("\n", items);
        return string.IsNullOrWhiteSpace(result) ? $"Directory {originalPath} is empty" : result;
    }

    private static IEnumerable<string> EnumerateSearchableFiles(string rootPath, string? includePattern)
    {
        if (!string.IsNullOrEmpty(includePattern))
        {
            var patterns = includePattern.Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
            foreach (var p in patterns)
            {
                foreach (var f in EnumerateFilesRecursive(rootPath, p))
                    yield return f;
            }
        }
        else
        {
            foreach (var f in EnumerateFilesRecursive(rootPath))
                yield return f;
        }
    }

    private static IEnumerable<string> EnumerateFilesRecursive(string rootPath, string searchPattern = "*")
    {
        var dirs = new Stack<string>();
        dirs.Push(rootPath);

        while (dirs.Count > 0)
        {
            var dir = dirs.Pop();

            IEnumerable<string> files;
            try
            {
                files = Directory.EnumerateFiles(dir, searchPattern);
            }
            catch { continue; }

            foreach (var file in files)
                yield return file;

            try
            {
                foreach (var subDir in Directory.EnumerateDirectories(dir))
                {
                    var dirName = Path.GetFileName(subDir);
                    if (SkipDirectories.Contains(dirName))
                        continue;
                    dirs.Push(subDir);
                }
            }
            catch
            {
                // ignored
            }
        }
    }

    private static bool IsBinaryFile(string filePath)
    {
        var ext = Path.GetExtension(filePath);
        return BinaryExtensions.Contains(ext);
    }

    private string ResolvePath(string path)
    {
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        if (!string.IsNullOrEmpty(home))
        {
            if (path == "~" || path.StartsWith("~/") || path.StartsWith("~\\"))
                path = Path.Combine(home, path[1..].TrimStart('/', '\\'));

            path = path.Replace("${HOME}", home).Replace("$HOME", home);
        }

        var expanded = Environment.ExpandEnvironmentVariables(path);
        return Path.IsPathRooted(expanded) 
            ? Path.GetFullPath(expanded) 
            : Path.GetFullPath(Path.Combine(_workspaceRoot, expanded));
    }

    private static readonly Regex UnicodeEscapeRegex = new(@"\\u([0-9a-fA-F]{4})", RegexOptions.Compiled);

    private static string UnescapeUnicodeSequences(string input)
    {
        if (!input.Contains("\\u"))
            return input;

        return UnicodeEscapeRegex.Replace(input, match =>
            ((char)Convert.ToInt32(match.Groups[1].Value, 16)).ToString());
    }

    private async Task<string?> ValidatePathAsync(string fullPath, string operation, string originalPath)
    {
        if (blacklist != null && blacklist.IsBlacklisted(fullPath))
        {
            return $"Error: Path '{originalPath}' is in the blacklist and cannot be accessed.";
        }

        var isWithinWorkspace = fullPath.StartsWith(_workspaceRoot, StringComparison.OrdinalIgnoreCase);
        
        if (!isWithinWorkspace)
        {
            if (operation is "read" or "list" && IsWithinTrustedReadPath(fullPath))
                return null;

            if (!requireApprovalOutsideWorkspace)
            {
                return $"Error: Path '{originalPath}' is outside workspace boundary.";
            }
            
            if (approvalService != null)
            {
                var context = ApprovalContextScope.Current;
                var approved = await approvalService.RequestFileApprovalAsync(operation, fullPath, context);
                if (!approved)
                {
                    return $"Error: Operation '{operation}' on '{originalPath}' was rejected by user.";
                }
            }
        }

        return null;
    }

    private bool IsWithinTrustedReadPath(string fullPath)
    {
        foreach (var trustedPath in _trustedReadPaths)
        {
            if (fullPath.StartsWith(trustedPath, StringComparison.OrdinalIgnoreCase))
                return true;
        }
        return false;
    }

    private static async Task<string> ApplyLineRangeEdit(
        string fullPath, string displayPath, string content, string newText, int startLine, int endLine)
    {
        var useCrLf = content.Contains("\r\n");
        var normalized = content.Replace("\r\n", "\n");
        var lines = normalized.Split('\n').ToList();

        var startIdx = startLine - 1;
        if (startIdx >= lines.Count)
            return $"Error: startLine {startLine} is out of range (file has {lines.Count} lines).";

        if (endLine < startLine) endLine = startLine;
        var endIdx = Math.Min(endLine, lines.Count) - 1;
        var removedCount = endIdx - startIdx + 1;

        lines.RemoveRange(startIdx, removedCount);

        if (!string.IsNullOrEmpty(newText))
        {
            var newLines = newText.Replace("\r\n", "\n").Split('\n');
            lines.InsertRange(startIdx, newLines);
        }

        var result = string.Join("\n", lines);
        if (useCrLf)
            result = result.Replace("\n", "\r\n");

        await File.WriteAllTextAsync(fullPath, result, Encoding.UTF8);
        return $"Successfully replaced lines {startLine}-{endLine} in {displayPath}";
    }

    private static async Task<string> ApplySearchReplaceEdit(
        string fullPath, string displayPath, string content, string oldText, string newText)
    {
        var count = CountOccurrences(content, oldText);
        if (count == 1)
        {
            var idx = content.IndexOf(oldText, StringComparison.Ordinal);
            var newContent = content[..idx] + newText + content[(idx + oldText.Length)..];
            await File.WriteAllTextAsync(fullPath, newContent, Encoding.UTF8);
            return $"Successfully edited {displayPath}";
        }
        if (count > 1)
            return $"Error: oldText appears {count} times in the file. Please provide more context to make it unique.";

        var found = TryLineTrimmedMatch(content, oldText);
        if (found != null)
        {
            var idx = content.IndexOf(found, StringComparison.Ordinal);
            if (idx != -1)
            {
                var newContent = content[..idx] + newText + content[(idx + found.Length)..];
                await File.WriteAllTextAsync(fullPath, newContent, Encoding.UTF8);
                return $"Successfully edited {displayPath} (matched via line-trimmed fallback)";
            }
        }

        found = TryIndentFlexibleMatch(content, oldText);
        if (found != null)
        {
            var idx = content.IndexOf(found, StringComparison.Ordinal);
            if (idx != -1)
            {
                var newContent = content[..idx] + newText + content[(idx + found.Length)..];
                await File.WriteAllTextAsync(fullPath, newContent, Encoding.UTF8);
                return $"Successfully edited {displayPath} (matched via indentation-flexible fallback)";
            }
        }

        var first50 = content.Length > 50 ? content[..50] : content;
        return $"Error: oldText not found in file. Make sure it matches the content. File has {content.Length} chars. First 50 chars: \"{first50}\"";
    }

    private static int CountOccurrences(string content, string searchText)
    {
        var count = 0;
        var pos = 0;
        while ((pos = content.IndexOf(searchText, pos, StringComparison.Ordinal)) != -1)
        {
            count++;
            pos += searchText.Length;
        }
        return count;
    }

    private static string? TryLineTrimmedMatch(string content, string oldText)
    {
        var contentLines = content.Split('\n');
        var searchLines = oldText.Split('\n');
        if (searchLines.Length == 0) return null;

        string? uniqueMatch = null;
        for (var i = 0; i <= contentLines.Length - searchLines.Length; i++)
        {
            var allMatch = true;
            for (var j = 0; j < searchLines.Length; j++)
            {
                if (contentLines[i + j].TrimEnd('\r').Trim() != searchLines[j].TrimEnd('\r').Trim())
                {
                    allMatch = false;
                    break;
                }
            }
            if (allMatch)
            {
                var block = string.Join("\n", contentLines.Skip(i).Take(searchLines.Length));
                if (uniqueMatch != null) return null;
                uniqueMatch = block;
            }
        }
        return uniqueMatch;
    }

    private static string? TryIndentFlexibleMatch(string content, string oldText)
    {
        var contentLines = content.Split('\n');
        var searchLines = oldText.Split('\n');
        if (searchLines.Length == 0) return null;

        var searchDeindented = DeindentLines(searchLines);
        string? uniqueMatch = null;

        for (var i = 0; i <= contentLines.Length - searchLines.Length; i++)
        {
            var blockLines = contentLines.Skip(i).Take(searchLines.Length).ToArray();
            var blockDeindented = DeindentLines(blockLines);
            if (blockDeindented.Length != searchDeindented.Length) continue;

            var allMatch = true;
            for (var j = 0; j < searchDeindented.Length; j++)
            {
                if (blockDeindented[j] != searchDeindented[j])
                {
                    allMatch = false;
                    break;
                }
            }
            if (allMatch)
            {
                var block = string.Join("\n", blockLines);
                if (uniqueMatch != null) return null;
                uniqueMatch = block;
            }
        }
        return uniqueMatch;
    }

    private static string[] DeindentLines(string[] lines)
    {
        var trimmed = lines.Select(l => l.TrimEnd('\r')).ToArray();
        var nonEmpty = trimmed.Where(l => l.Trim().Length > 0).ToArray();
        if (nonEmpty.Length == 0) return trimmed;

        var minIndent = nonEmpty.Min(l => l.Length - l.TrimStart().Length);
        return trimmed.Select(l => l.Length > minIndent ? l[minIndent..] : l.TrimStart()).ToArray();
    }

    #endregion
}
